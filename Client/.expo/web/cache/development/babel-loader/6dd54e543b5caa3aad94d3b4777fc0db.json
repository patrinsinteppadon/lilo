{"ast":null,"code":"'use strict';\n\nvar Dimensions = require(\"../../apis/Dimensions\");\n\nvar Platform = require(\"../../apis/Platform\");\n\nvar React = require('react');\n\nvar ReactDOM = require('react-dom');\n\nvar TextInputState = require(\"../../components/TextInput/TextInputState\");\n\nvar UIManager = require(\"../../apis/UIManager\");\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar warning = require('fbjs/lib/warning');\n\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollResponderMixin = {\n  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false\n    };\n  },\n  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {\n    return this.state.isTouching;\n  },\n  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  },\n  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {\n    return this.scrollResponderIsAnimating();\n  },\n  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {\n    warning(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  },\n  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {\n    var nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n    var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n\n    if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {\n      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {\n    this.state.lastMomentumScrollBeginTime = Date.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {\n    this.state.lastMomentumScrollEndTime = Date.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n  scrollResponderIsAnimating: function scrollResponderIsAnimating() {\n    var now = Date.now();\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {\n    return this.getScrollableNode ? this.getScrollableNode() : ReactDOM.findDOMNode(this);\n  },\n  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {\n    if (typeof x === 'number') {\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n    } else {\n      var _ref = x || {};\n\n      x = _ref.x;\n      y = _ref.y;\n      animated = _ref.animated;\n    }\n\n    var node = this.scrollResponderGetScrollableNode();\n    node.scrollLeft = x || 0;\n    node.scrollTop = y || 0;\n  },\n  scrollResponderScrollWithoutAnimationTo: function scrollResponderScrollWithoutAnimationTo(offsetX, offsetY) {\n    console.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');\n    this.scrollResponderScrollTo({\n      x: offsetX,\n      y: offsetY,\n      animated: false\n    });\n  },\n  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) {\n    if (Platform.OS !== 'ios') {\n      invariant('zoomToRect is not implemented');\n    }\n  },\n  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n    UIManager.measureLayout(nodeHandle, ReactDOM.findDOMNode(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n  },\n  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {\n    var keyboardScreenY = Dimensions.get('window').height;\n\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;\n\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n\n    this.scrollResponderScrollTo({\n      x: 0,\n      y: scrollOffsetY,\n      animated: true\n    });\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  },\n  componentWillMount: function componentWillMount() {\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0;\n  },\n  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  }\n};\nvar ScrollResponder = {\n  Mixin: ScrollResponderMixin\n};\nmodule.exports = ScrollResponder;","map":{"version":3,"sources":["/Users/paola/Documents/Capstone/lilo/node_modules/react-native-web-webrtc/node_modules/react-native-web/dist/modules/ScrollResponder/index.js"],"names":["Dimensions","require","Platform","React","ReactDOM","TextInputState","UIManager","invariant","warning","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","state","scrollResponderHandleStartShouldSetResponder","scrollResponderHandleStartShouldSetResponderCapture","e","scrollResponderIsAnimating","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","props","onTouchEnd","scrollResponderHandleResponderRelease","onResponderRelease","currentlyFocusedTextInput","currentlyFocusedField","keyboardShouldPersistTaps","target","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","Date","now","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","findDOMNode","scrollResponderScrollTo","x","y","animated","console","warn","_ref","node","scrollLeft","scrollTop","scrollResponderScrollWithoutAnimationTo","offsetX","offsetY","scrollResponderZoomTo","rect","OS","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","left","top","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","error","componentWillMount","scrollResponderKeyboardWillShow","onKeyboardWillShow","scrollResponderKeyboardWillHide","onKeyboardWillHide","scrollResponderKeyboardDidShow","onKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardDidHide","ScrollResponder","Mixin","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ScrollResponder\n * \n */\n'use strict';\n\nvar Dimensions=require('../../apis/Dimensions');\nvar Platform=require('../../apis/Platform');\nvar React=require('react');\nvar ReactDOM=require('react-dom');\n// var Subscribable = require('../Subscribable');\nvar TextInputState=require('../../components/TextInput/TextInputState');\nvar UIManager=require('../../apis/UIManager');\n\n// var { ScrollViewManager } = require('../../modules/NativeModules');\n\nvar invariant=require('fbjs/lib/invariant');\nvar warning=require('fbjs/lib/warning');\n\n// type Component = React.Component\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS=16;\n\n\n\n\n\n\n\n\n\n\nvar ScrollResponderMixin={\n// mixins: [Subscribable.Mixin],\nscrollResponderMixinGetInitialState:function scrollResponderMixinGetInitialState(){\nreturn{\nisTouching:false,\nlastMomentumScrollBeginTime:0,\nlastMomentumScrollEndTime:0,\n\n// Reset to false every time becomes responder. This is used to:\n// - Determine if the scroll view has been scrolled and therefore should\n// refuse to give up its responder lock.\n// - Determine if releasing should dismiss the keyboard when we are in\n// tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\nobservedScrollSinceBecomingResponder:false,\nbecameResponderWhileAnimating:false};\n\n},\n\n/**\n   * Invoke this from an `onScroll` event.\n   */\nscrollResponderHandleScrollShouldSetResponder:function scrollResponderHandleScrollShouldSetResponder(){\nreturn this.state.isTouching;\n},\n\n/**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\nscrollResponderHandleStartShouldSetResponder:function scrollResponderHandleStartShouldSetResponder(){\nreturn false;\n},\n\n/**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\nscrollResponderHandleStartShouldSetResponderCapture:function scrollResponderHandleStartShouldSetResponderCapture(e){\n// First see if we want to eat taps while the keyboard is up\n// var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n// if (!this.props.keyboardShouldPersistTaps &&\n//   currentlyFocusedTextInput != null &&\n//   e.target !== currentlyFocusedTextInput) {\n//   return true;\n// }\nreturn this.scrollResponderIsAnimating();\n},\n\n/**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\nscrollResponderHandleResponderReject:function scrollResponderHandleResponderReject(){\nwarning(false,\"ScrollView doesn't take rejection well - scrolls anyway\");\n},\n\n/**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\nscrollResponderHandleTerminationRequest:function scrollResponderHandleTerminationRequest(){\nreturn!this.state.observedScrollSinceBecomingResponder;\n},\n\n/**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\nscrollResponderHandleTouchEnd:function scrollResponderHandleTouchEnd(e){\nvar nativeEvent=e.nativeEvent;\nthis.state.isTouching=nativeEvent.touches.length!==0;\nthis.props.onTouchEnd&&this.props.onTouchEnd(e);\n},\n\n/**\n   * Invoke this from an `onResponderRelease` event.\n   */\nscrollResponderHandleResponderRelease:function scrollResponderHandleResponderRelease(e){\nthis.props.onResponderRelease&&this.props.onResponderRelease(e);\n\n// By default scroll views will unfocus a textField\n// if another touch occurs outside of it\nvar currentlyFocusedTextInput=TextInputState.currentlyFocusedField();\nif(!this.props.keyboardShouldPersistTaps&&\ncurrentlyFocusedTextInput!=null&&\ne.target!==currentlyFocusedTextInput&&\n!this.state.observedScrollSinceBecomingResponder&&\n!this.state.becameResponderWhileAnimating){\nthis.props.onScrollResponderKeyboardDismissed&&\nthis.props.onScrollResponderKeyboardDismissed(e);\nTextInputState.blurTextInput(currentlyFocusedTextInput);\n}\n},\n\nscrollResponderHandleScroll:function scrollResponderHandleScroll(e){\nthis.state.observedScrollSinceBecomingResponder=true;\nthis.props.onScroll&&this.props.onScroll(e);\n},\n\n/**\n   * Invoke this from an `onResponderGrant` event.\n   */\nscrollResponderHandleResponderGrant:function scrollResponderHandleResponderGrant(e){\nthis.state.observedScrollSinceBecomingResponder=false;\nthis.props.onResponderGrant&&this.props.onResponderGrant(e);\nthis.state.becameResponderWhileAnimating=this.scrollResponderIsAnimating();\n},\n\n/**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\nscrollResponderHandleScrollBeginDrag:function scrollResponderHandleScrollBeginDrag(e){\nthis.props.onScrollBeginDrag&&this.props.onScrollBeginDrag(e);\n},\n\n/**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\nscrollResponderHandleScrollEndDrag:function scrollResponderHandleScrollEndDrag(e){\nthis.props.onScrollEndDrag&&this.props.onScrollEndDrag(e);\n},\n\n/**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\nscrollResponderHandleMomentumScrollBegin:function scrollResponderHandleMomentumScrollBegin(e){\nthis.state.lastMomentumScrollBeginTime=Date.now();\nthis.props.onMomentumScrollBegin&&this.props.onMomentumScrollBegin(e);\n},\n\n/**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\nscrollResponderHandleMomentumScrollEnd:function scrollResponderHandleMomentumScrollEnd(e){\nthis.state.lastMomentumScrollEndTime=Date.now();\nthis.props.onMomentumScrollEnd&&this.props.onMomentumScrollEnd(e);\n},\n\n/**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\nscrollResponderHandleTouchStart:function scrollResponderHandleTouchStart(e){\nthis.state.isTouching=true;\nthis.props.onTouchStart&&this.props.onTouchStart(e);\n},\n\n/**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\nscrollResponderHandleTouchMove:function scrollResponderHandleTouchMove(e){\nthis.props.onTouchMove&&this.props.onTouchMove(e);\n},\n\n/**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\nscrollResponderIsAnimating:function scrollResponderIsAnimating(){\nvar now=Date.now();\nvar timeSinceLastMomentumScrollEnd=now-this.state.lastMomentumScrollEndTime;\nvar isAnimating=timeSinceLastMomentumScrollEnd<IS_ANIMATING_TOUCH_START_THRESHOLD_MS||\nthis.state.lastMomentumScrollEndTime<this.state.lastMomentumScrollBeginTime;\nreturn isAnimating;\n},\n\n/**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\nscrollResponderGetScrollableNode:function scrollResponderGetScrollableNode(){\nreturn this.getScrollableNode?\nthis.getScrollableNode():\nReactDOM.findDOMNode(this);\n},\n\n/**\n   * A helper function to scroll to a specific point  in the scrollview.\n   * This is currently used to help focus on child textviews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\nscrollResponderScrollTo:function scrollResponderScrollTo(\nx,\ny,\nanimated)\n{\nif(typeof x==='number'){\nconsole.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n}else{var _ref=\nx||{};x=_ref.x;y=_ref.y;animated=_ref.animated;\n}\nvar node=this.scrollResponderGetScrollableNode();\nnode.scrollLeft=x||0;\nnode.scrollTop=y||0;\n},\n\n/**\n   * Deprecated, do not use.\n   */\nscrollResponderScrollWithoutAnimationTo:function scrollResponderScrollWithoutAnimationTo(offsetX,offsetY){\nconsole.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');\nthis.scrollResponderScrollTo({x:offsetX,y:offsetY,animated:false});\n},\n\n/**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\nscrollResponderZoomTo:function scrollResponderZoomTo(\nrect,\nanimated// deprecated, put this inside the rect argument instead\n){\nif(Platform.OS!=='ios'){\ninvariant('zoomToRect is not implemented');\n}\n},\n\n/**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\nscrollResponderScrollNativeHandleToKeyboard:function scrollResponderScrollNativeHandleToKeyboard(nodeHandle,additionalOffset,preventNegativeScrollOffset){\nthis.additionalScrollOffset=additionalOffset||0;\nthis.preventNegativeScrollOffset=!!preventNegativeScrollOffset;\nUIManager.measureLayout(\nnodeHandle,\nReactDOM.findDOMNode(this.getInnerViewNode()),\nthis.scrollResponderTextInputFocusError,\nthis.scrollResponderInputMeasureAndScrollToKeyboard);\n\n},\n\n/**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\nscrollResponderInputMeasureAndScrollToKeyboard:function scrollResponderInputMeasureAndScrollToKeyboard(left,top,width,height){\nvar keyboardScreenY=Dimensions.get('window').height;\nif(this.keyboardWillOpenTo){\nkeyboardScreenY=this.keyboardWillOpenTo.endCoordinates.screenY;\n}\nvar scrollOffsetY=top-keyboardScreenY+height+this.additionalScrollOffset;\n\n// By default, this can scroll with negative offset, pulling the content\n// down so that the target component's bottom meets the keyboard's top.\n// If requested otherwise, cap the offset at 0 minimum to avoid content\n// shifting down.\nif(this.preventNegativeScrollOffset){\nscrollOffsetY=Math.max(0,scrollOffsetY);\n}\nthis.scrollResponderScrollTo({x:0,y:scrollOffsetY,animated:true});\n\nthis.additionalOffset=0;\nthis.preventNegativeScrollOffset=false;\n},\n\nscrollResponderTextInputFocusError:function scrollResponderTextInputFocusError(e){\nconsole.error('Error measuring text field: ',e);\n},\n\n/**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\ncomponentWillMount:function componentWillMount(){\nthis.keyboardWillOpenTo=null;\nthis.additionalScrollOffset=0;\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\n},\n\n/**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\nscrollResponderKeyboardWillShow:function scrollResponderKeyboardWillShow(e){\nthis.keyboardWillOpenTo=e;\nthis.props.onKeyboardWillShow&&this.props.onKeyboardWillShow(e);\n},\n\nscrollResponderKeyboardWillHide:function scrollResponderKeyboardWillHide(e){\nthis.keyboardWillOpenTo=null;\nthis.props.onKeyboardWillHide&&this.props.onKeyboardWillHide(e);\n},\n\nscrollResponderKeyboardDidShow:function scrollResponderKeyboardDidShow(e){\n// TODO(7693961): The event for DidShow is not available on iOS yet.\n// Use the one from WillShow and do not assign.\nif(e){\nthis.keyboardWillOpenTo=e;\n}\nthis.props.onKeyboardDidShow&&this.props.onKeyboardDidShow(e);\n},\n\nscrollResponderKeyboardDidHide:function scrollResponderKeyboardDidHide(e){\nthis.keyboardWillOpenTo=null;\nthis.props.onKeyboardDidHide&&this.props.onKeyboardDidHide(e);\n}};\n\n\nvar ScrollResponder={\nMixin:ScrollResponderMixin};\n\n\nmodule.exports=ScrollResponder;"]},"metadata":{},"sourceType":"script"}