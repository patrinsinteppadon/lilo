{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport EventTarget from 'event-target-shim';\nimport uuid from 'uuid';\nimport MediaStreamTrack from \"./MediaStreamTrack\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar MEDIA_STREAM_EVENTS = ['active', 'inactive', 'addtrack', 'removetrack'];\n\nvar MediaStream = function (_EventTarget) {\n  _inherits(MediaStream, _EventTarget);\n\n  var _super = _createSuper(MediaStream);\n\n  function MediaStream(arg) {\n    var _this;\n\n    _classCallCheck(this, MediaStream);\n\n    _this = _super.call(this);\n    _this.active = true;\n    _this._tracks = [];\n    _this.id = uuid.v4();\n    _this._reactTag = _this.id;\n\n    if (typeof arg === 'undefined') {\n      WebRTCModule.mediaStreamCreate(_this.id);\n    } else if (arg instanceof MediaStream) {\n      WebRTCModule.mediaStreamCreate(_this.id);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(arg.getTracks()), _step; !(_step = _iterator()).done;) {\n        var track = _step.value;\n\n        _this.addTrack(track);\n      }\n    } else if (Array.isArray(arg)) {\n      WebRTCModule.mediaStreamCreate(_this.id);\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(arg), _step2; !(_step2 = _iterator2()).done;) {\n        var _track = _step2.value;\n\n        _this.addTrack(_track);\n      }\n    } else if (typeof arg === 'object' && arg.streamId && arg.streamReactTag && arg.tracks) {\n      _this.id = arg.streamId;\n      _this._reactTag = arg.streamReactTag;\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(arg.tracks), _step3; !(_step3 = _iterator3()).done;) {\n        var trackInfo = _step3.value;\n\n        _this._tracks.push(new MediaStreamTrack(trackInfo));\n      }\n    } else {\n      throw new TypeError(\"invalid type: \" + typeof arg);\n    }\n\n    return _this;\n  }\n\n  _createClass(MediaStream, [{\n    key: \"addTrack\",\n    value: function addTrack(track) {\n      var index = this._tracks.indexOf(track);\n\n      if (index !== -1) {\n        return;\n      }\n\n      this._tracks.push(track);\n\n      WebRTCModule.mediaStreamAddTrack(this._reactTag, track.id);\n    }\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(track) {\n      var index = this._tracks.indexOf(track);\n\n      if (index === -1) {\n        return;\n      }\n\n      this._tracks.splice(index, 1);\n\n      WebRTCModule.mediaStreamRemoveTrack(this._reactTag, track.id);\n    }\n  }, {\n    key: \"getTracks\",\n    value: function getTracks() {\n      return this._tracks.slice();\n    }\n  }, {\n    key: \"getTrackById\",\n    value: function getTrackById(trackId) {\n      return this._tracks.find(function (track) {\n        return track.id === trackId;\n      });\n    }\n  }, {\n    key: \"getAudioTracks\",\n    value: function getAudioTracks() {\n      return this._tracks.filter(function (track) {\n        return track.kind === 'audio';\n      });\n    }\n  }, {\n    key: \"getVideoTracks\",\n    value: function getVideoTracks() {\n      return this._tracks.filter(function (track) {\n        return track.kind === 'video';\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toURL\",\n    value: function toURL() {\n      return this._reactTag;\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      var releaseTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(this._tracks), _step4; !(_step4 = _iterator4()).done;) {\n        var track = _step4.value;\n        this.removeTrack(track);\n\n        if (releaseTracks) {\n          track.release();\n        }\n      }\n\n      WebRTCModule.mediaStreamRelease(this._reactTag);\n    }\n  }]);\n\n  return MediaStream;\n}(EventTarget(MEDIA_STREAM_EVENTS));\n\nexport { MediaStream as default };","map":{"version":3,"sources":["/Users/paola/Documents/Capstone/lilo/node_modules/react-native-webrtc/MediaStream.js"],"names":["EventTarget","uuid","MediaStreamTrack","WebRTCModule","NativeModules","MEDIA_STREAM_EVENTS","MediaStream","arg","active","_tracks","id","v4","_reactTag","mediaStreamCreate","getTracks","track","addTrack","Array","isArray","streamId","streamReactTag","tracks","trackInfo","push","TypeError","index","indexOf","mediaStreamAddTrack","splice","mediaStreamRemoveTrack","slice","trackId","find","filter","kind","Error","releaseTracks","removeTrack","release","mediaStreamRelease"],"mappings":"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","sourcesContent":["'use strict';\n\nimport {NativeModules} from 'react-native';\nimport EventTarget from 'event-target-shim';\nimport uuid from 'uuid';\n\nimport MediaStreamTrack from './MediaStreamTrack';\n\nconst {WebRTCModule} = NativeModules;\n\nconst MEDIA_STREAM_EVENTS = [\n  'active',\n  'inactive',\n  'addtrack',\n  'removetrack',\n];\n\nexport default class MediaStream extends EventTarget(MEDIA_STREAM_EVENTS) {\n  id: string;\n  active: boolean = true;\n\n  onactive: ?Function;\n  oninactive: ?Function;\n  onaddtrack: ?Function;\n  onremovetrack: ?Function;\n\n  _tracks: Array<MediaStreamTrack> = [];\n\n  /**\n   * The identifier of this MediaStream unique within the associated\n   * WebRTCModule instance. As the id of a remote MediaStream instance is unique\n   * only within the associated RTCPeerConnection, it is not sufficiently unique\n   * to identify this MediaStream across multiple RTCPeerConnections and to\n   * unambiguously differentiate it from a local MediaStream instance not added\n   * to an RTCPeerConnection.\n   */\n  _reactTag: string;\n\n  /**\n   * A MediaStream can be constructed in several ways, depending on the paramters\n   * that are passed here.\n   *\n   * - undefined: just a new stream, with no tracks.\n   * - MediaStream instance: a new stream, with a copy of the tracks of the passed stream.\n   * - Array of MediaStreamTrack: a new stream with a copy of the tracks in the array.\n   * - object: a new stream instance, represented by the passed info object, this is always\n   *   done internally, when the stream is first created in native and the JS wrapper is\n   *   built afterwards.\n   */\n  constructor(arg) {\n      super();\n\n      // Assigm a UUID to start with. It may get overridden for remote streams.\n      this.id = uuid.v4();\n      // Local MediaStreams are created by WebRTCModule to have their id and\n      // reactTag equal because WebRTCModule follows the respective standard's\n      // recommendation for id generation i.e. uses UUID which is unique enough\n      // for the purposes of reactTag.\n      this._reactTag = this.id;\n\n      if (typeof arg === 'undefined') {\n          WebRTCModule.mediaStreamCreate(this.id);\n      } else if (arg instanceof MediaStream) {\n          WebRTCModule.mediaStreamCreate(this.id);\n          for (const track of arg.getTracks()) {\n              this.addTrack(track);\n          }\n      } else if (Array.isArray(arg)) {\n          WebRTCModule.mediaStreamCreate(this.id);\n          for (const track of arg) {\n              this.addTrack(track);\n          }\n      } else if (typeof arg === 'object' && arg.streamId && arg.streamReactTag && arg.tracks) {\n          this.id = arg.streamId;\n          this._reactTag = arg.streamReactTag;\n          for (const trackInfo of arg.tracks) {\n              // We are not using addTrack here because the track is already part of the\n              // stream, so there is no need to add it on the native side.\n              this._tracks.push(new MediaStreamTrack(trackInfo));\n          }\n      } else {\n          throw new TypeError(`invalid type: ${typeof arg}`);\n      }\n  }\n\n  addTrack(track: MediaStreamTrack) {\n      const index = this._tracks.indexOf(track);\n      if (index !== -1) {\n          return;\n      }\n      this._tracks.push(track);\n      WebRTCModule.mediaStreamAddTrack(this._reactTag, track.id);\n  }\n\n  removeTrack(track: MediaStreamTrack) {\n      const index = this._tracks.indexOf(track);\n      if (index === -1) {\n        return;\n      }\n      this._tracks.splice(index, 1);\n      WebRTCModule.mediaStreamRemoveTrack(this._reactTag, track.id);\n  }\n\n  getTracks(): Array<MediaStreamTrack> {\n    return this._tracks.slice();\n  }\n\n  getTrackById(trackId): ?MediaStreamTrack {\n    return this._tracks.find(track => track.id === trackId);\n  }\n\n  getAudioTracks(): Array<MediaStreamTrack> {\n    return this._tracks.filter(track => track.kind === 'audio');\n  }\n\n  getVideoTracks(): Array<MediaStreamTrack> {\n    return this._tracks.filter(track => track.kind === 'video');\n  }\n\n  clone() {\n    throw new Error('Not implemented.');\n  }\n\n  toURL() {\n    return this._reactTag;\n  }\n\n  release(releaseTracks = true) {\n    for (const track of this._tracks) {\n      this.removeTrack(track);\n      if (releaseTracks) {\n        track.release();\n      }\n    }\n\n    WebRTCModule.mediaStreamRelease(this._reactTag);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}