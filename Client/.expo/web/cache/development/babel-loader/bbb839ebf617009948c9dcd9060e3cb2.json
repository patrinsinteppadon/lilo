{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar isEmpty = require('fbjs/lib/isEmpty');\n\nvar warning = require('fbjs/lib/warning');\n\nfunction defaultGetRowData(dataBlob, sectionID, rowID) {\n  return dataBlob[sectionID][rowID];\n}\n\nfunction defaultGetSectionHeaderData(dataBlob, sectionID) {\n  return dataBlob[sectionID];\n}\n\nvar ListViewDataSource = function () {\n  function ListViewDataSource(params) {\n    _classCallCheck(this, ListViewDataSource);\n\n    invariant(params && typeof params.rowHasChanged === 'function', 'Must provide a rowHasChanged function.');\n    this._rowHasChanged = params.rowHasChanged;\n    this._getRowData = params.getRowData || defaultGetRowData;\n    this._sectionHeaderHasChanged = params.sectionHeaderHasChanged;\n    this._getSectionHeaderData = params.getSectionHeaderData || defaultGetSectionHeaderData;\n    this._dataBlob = null;\n    this._dirtyRows = [];\n    this._dirtySections = [];\n    this._cachedRowCount = 0;\n    this.rowIdentities = [];\n    this.sectionIdentities = [];\n  }\n\n  _createClass(ListViewDataSource, [{\n    key: 'cloneWithRows',\n    value: function cloneWithRows(dataBlob, rowIdentities) {\n      var rowIds = rowIdentities ? [rowIdentities] : null;\n\n      if (!this._sectionHeaderHasChanged) {\n        this._sectionHeaderHasChanged = function () {\n          return false;\n        };\n      }\n\n      return this.cloneWithRowsAndSections({\n        s1: dataBlob\n      }, ['s1'], rowIds);\n    }\n  }, {\n    key: 'cloneWithRowsAndSections',\n    value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {\n      invariant(typeof this._sectionHeaderHasChanged === 'function', 'Must provide a sectionHeaderHasChanged function with section data.');\n      var newSource = new ListViewDataSource({\n        getRowData: this._getRowData,\n        getSectionHeaderData: this._getSectionHeaderData,\n        rowHasChanged: this._rowHasChanged,\n        sectionHeaderHasChanged: this._sectionHeaderHasChanged\n      });\n      newSource._dataBlob = dataBlob;\n\n      if (sectionIdentities) {\n        newSource.sectionIdentities = sectionIdentities;\n      } else {\n        newSource.sectionIdentities = Object.keys(dataBlob);\n      }\n\n      if (rowIdentities) {\n        newSource.rowIdentities = rowIdentities;\n      } else {\n        newSource.rowIdentities = [];\n        newSource.sectionIdentities.forEach(function (sectionID) {\n          newSource.rowIdentities.push(Object.keys(dataBlob[sectionID]));\n        });\n      }\n\n      newSource._cachedRowCount = countRows(newSource.rowIdentities);\n\n      newSource._calculateDirtyArrays(this._dataBlob, this.sectionIdentities, this.rowIdentities);\n\n      return newSource;\n    }\n  }, {\n    key: 'getRowCount',\n    value: function getRowCount() {\n      return this._cachedRowCount;\n    }\n  }, {\n    key: 'rowShouldUpdate',\n    value: function rowShouldUpdate(sectionIndex, rowIndex) {\n      var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];\n      warning(needsUpdate !== undefined, 'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);\n      return needsUpdate;\n    }\n  }, {\n    key: 'getRowData',\n    value: function getRowData(sectionIndex, rowIndex) {\n      var sectionID = this.sectionIdentities[sectionIndex];\n      var rowID = this.rowIdentities[sectionIndex][rowIndex];\n      warning(sectionID !== undefined && rowID !== undefined, 'rendering invalid section, row: ' + sectionIndex + ', ' + rowIndex);\n      return this._getRowData(this._dataBlob, sectionID, rowID);\n    }\n  }, {\n    key: 'getRowIDForFlatIndex',\n    value: function getRowIDForFlatIndex(index) {\n      var accessIndex = index;\n\n      for (var ii = 0; ii < this.sectionIdentities.length; ii++) {\n        if (accessIndex >= this.rowIdentities[ii].length) {\n          accessIndex -= this.rowIdentities[ii].length;\n        } else {\n          return this.rowIdentities[ii][accessIndex];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getSectionIDForFlatIndex',\n    value: function getSectionIDForFlatIndex(index) {\n      var accessIndex = index;\n\n      for (var ii = 0; ii < this.sectionIdentities.length; ii++) {\n        if (accessIndex >= this.rowIdentities[ii].length) {\n          accessIndex -= this.rowIdentities[ii].length;\n        } else {\n          return this.sectionIdentities[ii];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getSectionLengths',\n    value: function getSectionLengths() {\n      var results = [];\n\n      for (var ii = 0; ii < this.sectionIdentities.length; ii++) {\n        results.push(this.rowIdentities[ii].length);\n      }\n\n      return results;\n    }\n  }, {\n    key: 'sectionHeaderShouldUpdate',\n    value: function sectionHeaderShouldUpdate(sectionIndex) {\n      var needsUpdate = this._dirtySections[sectionIndex];\n      warning(needsUpdate !== undefined, 'missing dirtyBit for section: ' + sectionIndex);\n      return needsUpdate;\n    }\n  }, {\n    key: 'getSectionHeaderData',\n    value: function getSectionHeaderData(sectionIndex) {\n      if (!this._getSectionHeaderData) {\n        return null;\n      }\n\n      var sectionID = this.sectionIdentities[sectionIndex];\n      warning(sectionID !== undefined, 'renderSection called on invalid section: ' + sectionIndex);\n      return this._getSectionHeaderData(this._dataBlob, sectionID);\n    }\n  }, {\n    key: '_calculateDirtyArrays',\n    value: function _calculateDirtyArrays(prevDataBlob, prevSectionIDs, prevRowIDs) {\n      var prevSectionsHash = keyedDictionaryFromArray(prevSectionIDs);\n      var prevRowsHash = {};\n\n      for (var ii = 0; ii < prevRowIDs.length; ii++) {\n        var sectionID = prevSectionIDs[ii];\n        warning(!prevRowsHash[sectionID], 'SectionID appears more than once: ' + sectionID);\n        prevRowsHash[sectionID] = keyedDictionaryFromArray(prevRowIDs[ii]);\n      }\n\n      this._dirtySections = [];\n      this._dirtyRows = [];\n      var dirty;\n\n      for (var sIndex = 0; sIndex < this.sectionIdentities.length; sIndex++) {\n        var sectionID = this.sectionIdentities[sIndex];\n        dirty = !prevSectionsHash[sectionID];\n        var sectionHeaderHasChanged = this._sectionHeaderHasChanged;\n\n        if (!dirty && sectionHeaderHasChanged) {\n          dirty = sectionHeaderHasChanged(this._getSectionHeaderData(prevDataBlob, sectionID), this._getSectionHeaderData(this._dataBlob, sectionID));\n        }\n\n        this._dirtySections.push(!!dirty);\n\n        this._dirtyRows[sIndex] = [];\n\n        for (var rIndex = 0; rIndex < this.rowIdentities[sIndex].length; rIndex++) {\n          var rowID = this.rowIdentities[sIndex][rIndex];\n          dirty = !prevSectionsHash[sectionID] || !prevRowsHash[sectionID][rowID] || this._rowHasChanged(this._getRowData(prevDataBlob, sectionID, rowID), this._getRowData(this._dataBlob, sectionID, rowID));\n\n          this._dirtyRows[sIndex].push(!!dirty);\n        }\n      }\n    }\n  }]);\n\n  return ListViewDataSource;\n}();\n\nfunction countRows(allRowIDs) {\n  var totalRows = 0;\n\n  for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {\n    var rowIDs = allRowIDs[sectionIdx];\n    totalRows += rowIDs.length;\n  }\n\n  return totalRows;\n}\n\nfunction keyedDictionaryFromArray(arr) {\n  if (isEmpty(arr)) {\n    return {};\n  }\n\n  var result = {};\n\n  for (var ii = 0; ii < arr.length; ii++) {\n    var key = arr[ii];\n    warning(!result[key], 'Value appears more than once in array: ' + key);\n    result[key] = true;\n  }\n\n  return result;\n}\n\nmodule.exports = ListViewDataSource;","map":{"version":3,"sources":["/Users/paola/Documents/Capstone/lilo/node_modules/react-native-web-webrtc/node_modules/react-native-web/dist/components/ListView/ListViewDataSource.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","invariant","require","isEmpty","warning","defaultGetRowData","dataBlob","sectionID","rowID","defaultGetSectionHeaderData","ListViewDataSource","params","rowHasChanged","_rowHasChanged","_getRowData","getRowData","_sectionHeaderHasChanged","sectionHeaderHasChanged","_getSectionHeaderData","getSectionHeaderData","_dataBlob","_dirtyRows","_dirtySections","_cachedRowCount","rowIdentities","sectionIdentities","value","cloneWithRows","rowIds","cloneWithRowsAndSections","s1","newSource","keys","forEach","push","countRows","_calculateDirtyArrays","getRowCount","rowShouldUpdate","sectionIndex","rowIndex","needsUpdate","undefined","getRowIDForFlatIndex","index","accessIndex","ii","getSectionIDForFlatIndex","getSectionLengths","results","sectionHeaderShouldUpdate","prevDataBlob","prevSectionIDs","prevRowIDs","prevSectionsHash","keyedDictionaryFromArray","prevRowsHash","dirty","sIndex","rIndex","allRowIDs","totalRows","sectionIdx","rowIDs","arr","result","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/**\n * Copyright (c) 2015, Facebook, Inc.  All rights reserved.\n *\n * Facebook, Inc. (\"Facebook\") owns all right, title and interest, including\n * all intellectual property and other proprietary rights, in and to the React\n * Native CustomComponents software (the \"Software\").  Subject to your\n * compliance with these terms, you are hereby granted a non-exclusive,\n * worldwide, royalty-free copyright license to (1) use and copy the Software;\n * and (2) reproduce and distribute the Software as part of your own software\n * (\"Your Software\").  Facebook reserves all rights not expressly granted to\n * you in this license agreement.\n *\n * THE SOFTWARE AND DOCUMENTATION, IF ANY, ARE PROVIDED \"AS IS\" AND ANY EXPRESS\n * OR IMPLIED WARRANTIES (INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE) ARE DISCLAIMED.\n * IN NO EVENT SHALL FACEBOOK OR ITS AFFILIATES, OFFICERS, DIRECTORS OR\n * EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * @providesModule ListViewDataSource\n * @typechecks\n * \n */\n'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}\n\nvar invariant=require('fbjs/lib/invariant');\nvar isEmpty=require('fbjs/lib/isEmpty');\nvar warning=require('fbjs/lib/warning');\n\nfunction defaultGetRowData(\ndataBlob,\nsectionID,\nrowID)\n{\nreturn dataBlob[sectionID][rowID];\n}\n\nfunction defaultGetSectionHeaderData(\ndataBlob,\nsectionID)\n{\nreturn dataBlob[sectionID];\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * Provides efficient data processing and access to the\n * `ListView` component.  A `ListViewDataSource` is created with functions for\n * extracting data from the input blob, and comparing elements (with default\n * implementations for convenience).  The input blob can be as simple as an\n * array of strings, or an object with rows nested inside section objects.\n *\n * To update the data in the datasource, use `cloneWithRows` (or\n * `cloneWithRowsAndSections` if you care about sections).  The data in the\n * data source is immutable, so you can't modify it directly.  The clone methods\n * suck in the new data and compute a diff for each row so ListView knows\n * whether to re-render it or not.\n *\n * In this example, a component receives data in chunks, handled by\n * `_onDataArrived`, which concats the new data onto the old data and updates the\n * data source.  We use `concat` to create a new array - mutating `this._data`,\n * e.g. with `this._data.push(newRowData)`, would be an error. `_rowHasChanged`\n * understands the shape of the row data and knows how to efficiently compare\n * it.\n *\n * ```\n * getInitialState: function() {\n *   var ds = new ListViewDataSource({rowHasChanged: this._rowHasChanged});\n *   return {ds};\n * },\n * _onDataArrived(newData) {\n *   this._data = this._data.concat(newData);\n *   this.setState({\n *     ds: this.state.ds.cloneWithRows(this._data)\n *   });\n * }\n * ```\n */var\n\nListViewDataSource=function(){\n\n/**\n   * You can provide custom extraction and `hasChanged` functions for section\n   * headers and rows.  If absent, data will be extracted with the\n   * `defaultGetRowData` and `defaultGetSectionHeaderData` functions.\n   *\n   * The default extractor expects data of one of the following forms:\n   *\n   *      { sectionID_1: { rowID_1: <rowData1>, ... }, ... }\n   *\n   *    or\n   *\n   *      { sectionID_1: [ <rowData1>, <rowData2>, ... ], ... }\n   *\n   *    or\n   *\n   *      [ [ <rowData1>, <rowData2>, ... ], ... ]\n   *\n   * The constructor takes in a params argument that can contain any of the\n   * following:\n   *\n   * - getRowData(dataBlob, sectionID, rowID);\n   * - getSectionHeaderData(dataBlob, sectionID);\n   * - rowHasChanged(prevRowData, nextRowData);\n   * - sectionHeaderHasChanged(prevSectionData, nextSectionData);\n   */\nfunction ListViewDataSource(params){_classCallCheck(this,ListViewDataSource);\ninvariant(\nparams&&typeof params.rowHasChanged==='function',\n'Must provide a rowHasChanged function.');\n\nthis._rowHasChanged=params.rowHasChanged;\nthis._getRowData=params.getRowData||defaultGetRowData;\nthis._sectionHeaderHasChanged=params.sectionHeaderHasChanged;\nthis._getSectionHeaderData=\nparams.getSectionHeaderData||defaultGetSectionHeaderData;\n\nthis._dataBlob=null;\nthis._dirtyRows=[];\nthis._dirtySections=[];\nthis._cachedRowCount=0;\n\n// These two private variables are accessed by outsiders because ListView\n// uses them to iterate over the data in this class.\nthis.rowIdentities=[];\nthis.sectionIdentities=[];\n}\n\n/**\n   * Clones this `ListViewDataSource` with the specified `dataBlob` and\n   * `rowIdentities`. The `dataBlob` is just an arbitrary blob of data. At\n   * construction an extractor to get the interesting information was defined\n   * (or the default was used).\n   *\n   * The `rowIdentities` is is a 2D array of identifiers for rows.\n   * ie. [['a1', 'a2'], ['b1', 'b2', 'b3'], ...].  If not provided, it's\n   * assumed that the keys of the section data are the row identities.\n   *\n   * Note: This function does NOT clone the data in this data source. It simply\n   * passes the functions defined at construction to a new data source with\n   * the data specified. If you wish to maintain the existing data you must\n   * handle merging of old and new data separately and then pass that into\n   * this function as the `dataBlob`.\n   */_createClass(ListViewDataSource,[{key:'cloneWithRows',value:function cloneWithRows(\n\ndataBlob,\nrowIdentities)\n{\nvar rowIds=rowIdentities?[rowIdentities]:null;\nif(!this._sectionHeaderHasChanged){\nthis._sectionHeaderHasChanged=function(){return false;};\n}\nreturn this.cloneWithRowsAndSections({s1:dataBlob},['s1'],rowIds);\n}\n\n/**\n   * This performs the same function as the `cloneWithRows` function but here\n   * you also specify what your `sectionIdentities` are. If you don't care\n   * about sections you should safely be able to use `cloneWithRows`.\n   *\n   * `sectionIdentities` is an array of identifiers for  sections.\n   * ie. ['s1', 's2', ...].  If not provided, it's assumed that the\n   * keys of dataBlob are the section identities.\n   *\n   * Note: this returns a new object!\n   */},{key:'cloneWithRowsAndSections',value:function cloneWithRowsAndSections(\n\ndataBlob,\nsectionIdentities,\nrowIdentities)\n{\ninvariant(\ntypeof this._sectionHeaderHasChanged==='function',\n'Must provide a sectionHeaderHasChanged function with section data.');\n\nvar newSource=new ListViewDataSource({\ngetRowData:this._getRowData,\ngetSectionHeaderData:this._getSectionHeaderData,\nrowHasChanged:this._rowHasChanged,\nsectionHeaderHasChanged:this._sectionHeaderHasChanged});\n\nnewSource._dataBlob=dataBlob;\nif(sectionIdentities){\nnewSource.sectionIdentities=sectionIdentities;\n}else{\nnewSource.sectionIdentities=Object.keys(dataBlob);\n}\nif(rowIdentities){\nnewSource.rowIdentities=rowIdentities;\n}else{\nnewSource.rowIdentities=[];\nnewSource.sectionIdentities.forEach(function(sectionID){\nnewSource.rowIdentities.push(Object.keys(dataBlob[sectionID]));\n});\n}\nnewSource._cachedRowCount=countRows(newSource.rowIdentities);\n\nnewSource._calculateDirtyArrays(\nthis._dataBlob,\nthis.sectionIdentities,\nthis.rowIdentities);\n\n\nreturn newSource;\n}},{key:'getRowCount',value:function getRowCount()\n\n{\nreturn this._cachedRowCount;\n}\n\n/**\n   * Returns if the row is dirtied and needs to be rerendered\n   */},{key:'rowShouldUpdate',value:function rowShouldUpdate(\nsectionIndex,rowIndex){\nvar needsUpdate=this._dirtyRows[sectionIndex][rowIndex];\nwarning(needsUpdate!==undefined,\n'missing dirtyBit for section, row: '+sectionIndex+', '+rowIndex);\nreturn needsUpdate;\n}\n\n/**\n   * Gets the data required to render the row.\n   */},{key:'getRowData',value:function getRowData(\nsectionIndex,rowIndex){\nvar sectionID=this.sectionIdentities[sectionIndex];\nvar rowID=this.rowIdentities[sectionIndex][rowIndex];\nwarning(\nsectionID!==undefined&&rowID!==undefined,\n'rendering invalid section, row: '+sectionIndex+', '+rowIndex);\n\nreturn this._getRowData(this._dataBlob,sectionID,rowID);\n}\n\n/**\n   * Gets the rowID at index provided if the dataSource arrays were flattened,\n   * or null of out of range indexes.\n   */},{key:'getRowIDForFlatIndex',value:function getRowIDForFlatIndex(\nindex){\nvar accessIndex=index;\nfor(var ii=0;ii<this.sectionIdentities.length;ii++){\nif(accessIndex>=this.rowIdentities[ii].length){\naccessIndex-=this.rowIdentities[ii].length;\n}else{\nreturn this.rowIdentities[ii][accessIndex];\n}\n}\nreturn null;\n}\n\n/**\n   * Gets the sectionID at index provided if the dataSource arrays were flattened,\n   * or null for out of range indexes.\n   */},{key:'getSectionIDForFlatIndex',value:function getSectionIDForFlatIndex(\nindex){\nvar accessIndex=index;\nfor(var ii=0;ii<this.sectionIdentities.length;ii++){\nif(accessIndex>=this.rowIdentities[ii].length){\naccessIndex-=this.rowIdentities[ii].length;\n}else{\nreturn this.sectionIdentities[ii];\n}\n}\nreturn null;\n}\n\n/**\n   * Returns an array containing the number of rows in each section\n   */},{key:'getSectionLengths',value:function getSectionLengths()\n{\nvar results=[];\nfor(var ii=0;ii<this.sectionIdentities.length;ii++){\nresults.push(this.rowIdentities[ii].length);\n}\nreturn results;\n}\n\n/**\n   * Returns if the section header is dirtied and needs to be rerendered\n   */},{key:'sectionHeaderShouldUpdate',value:function sectionHeaderShouldUpdate(\nsectionIndex){\nvar needsUpdate=this._dirtySections[sectionIndex];\nwarning(needsUpdate!==undefined,\n'missing dirtyBit for section: '+sectionIndex);\nreturn needsUpdate;\n}\n\n/**\n   * Gets the data required to render the section header\n   */},{key:'getSectionHeaderData',value:function getSectionHeaderData(\nsectionIndex){\nif(!this._getSectionHeaderData){\nreturn null;\n}\nvar sectionID=this.sectionIdentities[sectionIndex];\nwarning(sectionID!==undefined,\n'renderSection called on invalid section: '+sectionIndex);\nreturn this._getSectionHeaderData(this._dataBlob,sectionID);\n}\n\n/**\n   * Private members and methods.\n   */\n\n\n\n\n\n\n\n\n\n\n\n// These two 'protected' variables are accessed by ListView to iterate over\n// the data in this class.\n},{key:'_calculateDirtyArrays',value:function _calculateDirtyArrays(\n\n\n\nprevDataBlob,\nprevSectionIDs,\nprevRowIDs)\n{\n// construct a hashmap of the existing (old) id arrays\nvar prevSectionsHash=keyedDictionaryFromArray(prevSectionIDs);\nvar prevRowsHash={};\nfor(var ii=0;ii<prevRowIDs.length;ii++){\nvar sectionID=prevSectionIDs[ii];\nwarning(\n!prevRowsHash[sectionID],\n'SectionID appears more than once: '+sectionID);\n\nprevRowsHash[sectionID]=keyedDictionaryFromArray(prevRowIDs[ii]);\n}\n\n// compare the 2 identity array and get the dirtied rows\nthis._dirtySections=[];\nthis._dirtyRows=[];\n\nvar dirty;\nfor(var sIndex=0;sIndex<this.sectionIdentities.length;sIndex++){\nvar sectionID=this.sectionIdentities[sIndex];\n// dirty if the sectionHeader is new or _sectionHasChanged is true\ndirty=!prevSectionsHash[sectionID];\nvar sectionHeaderHasChanged=this._sectionHeaderHasChanged;\nif(!dirty&&sectionHeaderHasChanged){\ndirty=sectionHeaderHasChanged(\nthis._getSectionHeaderData(prevDataBlob,sectionID),\nthis._getSectionHeaderData(this._dataBlob,sectionID));\n\n}\nthis._dirtySections.push(!!dirty);\n\nthis._dirtyRows[sIndex]=[];\nfor(var rIndex=0;rIndex<this.rowIdentities[sIndex].length;rIndex++){\nvar rowID=this.rowIdentities[sIndex][rIndex];\n// dirty if the section is new, row is new or _rowHasChanged is true\ndirty=\n!prevSectionsHash[sectionID]||\n!prevRowsHash[sectionID][rowID]||\nthis._rowHasChanged(\nthis._getRowData(prevDataBlob,sectionID,rowID),\nthis._getRowData(this._dataBlob,sectionID,rowID));\n\nthis._dirtyRows[sIndex].push(!!dirty);\n}\n}\n}}]);return ListViewDataSource;}();\n\n\nfunction countRows(allRowIDs){\nvar totalRows=0;\nfor(var sectionIdx=0;sectionIdx<allRowIDs.length;sectionIdx++){\nvar rowIDs=allRowIDs[sectionIdx];\ntotalRows+=rowIDs.length;\n}\nreturn totalRows;\n}\n\nfunction keyedDictionaryFromArray(arr){\nif(isEmpty(arr)){\nreturn{};\n}\nvar result={};\nfor(var ii=0;ii<arr.length;ii++){\nvar key=arr[ii];\nwarning(!result[key],'Value appears more than once in array: '+key);\nresult[key]=true;\n}\nreturn result;\n}\n\n\nmodule.exports=ListViewDataSource;"]},"metadata":{},"sourceType":"script"}