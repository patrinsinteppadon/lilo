{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport * as RTCUtil from \"./RTCUtil\";\nimport MediaStream from \"./MediaStream\";\nimport MediaStreamError from \"./MediaStreamError\";\nimport permissions from \"./Permissions\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nexport default function getUserMedia() {\n  var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (typeof constraints !== 'object') {\n    return Promise.reject(new TypeError('constraints is not a dictionary'));\n  }\n\n  if ((typeof constraints.audio === 'undefined' || !constraints.audio) && (typeof constraints.video === 'undefined' || !constraints.video)) {\n    return Promise.reject(new TypeError('audio and/or video is required'));\n  }\n\n  constraints = RTCUtil.normalizeConstraints(constraints);\n  var reqPermissions = [];\n\n  if (constraints.audio) {\n    reqPermissions.push(permissions.request({\n      name: 'microphone'\n    }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  if (constraints.video) {\n    reqPermissions.push(permissions.request({\n      name: 'camera'\n    }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  return new Promise(function (resolve, reject) {\n    Promise.all(reqPermissions).then(function (results) {\n      var _results = _slicedToArray(results, 2),\n          audioPerm = _results[0],\n          videoPerm = _results[1];\n\n      if (!audioPerm && !videoPerm) {\n        var error = {\n          message: 'Permission denied.',\n          name: 'SecurityError'\n        };\n        reject(new MediaStreamError(error));\n        return;\n      }\n\n      audioPerm || delete constraints.audio;\n      videoPerm || delete constraints.video;\n\n      var success = function success(id, tracks) {\n        for (var _iterator = _createForOfIteratorHelperLoose(tracks), _step; !(_step = _iterator()).done;) {\n          var trackInfo = _step.value;\n          var c = constraints[trackInfo.kind];\n\n          if (typeof c === 'object') {\n            trackInfo.constraints = RTCUtil.deepClone(c);\n          }\n        }\n\n        var info = {\n          streamId: id,\n          streamReactTag: id,\n          tracks: tracks\n        };\n        resolve(new MediaStream(info));\n      };\n\n      var failure = function failure(type, message) {\n        var error;\n\n        switch (type) {\n          case 'TypeError':\n            error = new TypeError(message);\n            break;\n        }\n\n        if (!error) {\n          error = new MediaStreamError({\n            message: message,\n            name: type\n          });\n        }\n\n        reject(error);\n      };\n\n      WebRTCModule.getUserMedia(constraints, success, failure);\n    });\n  });\n}","map":{"version":3,"sources":["/Users/paola/Documents/Capstone/lilo/node_modules/react-native-webrtc/getUserMedia.js"],"names":["RTCUtil","MediaStream","MediaStreamError","permissions","WebRTCModule","NativeModules","getUserMedia","constraints","Promise","reject","TypeError","audio","video","normalizeConstraints","reqPermissions","push","request","name","resolve","all","then","results","audioPerm","videoPerm","error","message","success","id","tracks","trackInfo","c","kind","deepClone","info","streamId","streamReactTag","failure","type"],"mappings":"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","sourcesContent":["'use strict';\n\nimport {Platform, NativeModules} from 'react-native';\nimport * as RTCUtil from './RTCUtil';\n\nimport MediaStream from './MediaStream';\nimport MediaStreamError from './MediaStreamError';\nimport permissions from './Permissions';\n\nconst { WebRTCModule } = NativeModules;\n\n\nexport default function getUserMedia(constraints = {}) {\n  // According to\n  // https://www.w3.org/TR/mediacapture-streams/#dom-mediadevices-getusermedia,\n  // the constraints argument is a dictionary of type MediaStreamConstraints.\n  if (typeof constraints !== 'object') {\n    return Promise.reject(new TypeError('constraints is not a dictionary'));\n  }\n\n  if ((typeof constraints.audio === 'undefined' || !constraints.audio)\n      && (typeof constraints.video === 'undefined' || !constraints.video)) {\n    return Promise.reject(new TypeError('audio and/or video is required'));\n  }\n\n  // Normalize constraints.\n  constraints = RTCUtil.normalizeConstraints(constraints);\n\n  // Request required permissions\n  const reqPermissions = [];\n  if (constraints.audio) {\n    reqPermissions.push(permissions.request({ name: 'microphone' }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n  if (constraints.video) {\n    reqPermissions.push(permissions.request({ name: 'camera' }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  return new Promise((resolve, reject) => {\n    Promise.all(reqPermissions).then(results => {\n      const [ audioPerm, videoPerm ] = results;\n\n      // Check permission results and remove unneeded permissions.\n\n      if (!audioPerm && !videoPerm) {\n        // https://www.w3.org/TR/mediacapture-streams/#dom-mediadevices-getusermedia\n        // step 4\n        const error = {\n          message: 'Permission denied.',\n          name: 'SecurityError'\n        };\n        reject(new MediaStreamError(error));\n\n        return;\n      }\n\n      audioPerm || (delete constraints.audio);\n      videoPerm || (delete constraints.video);\n\n      const success = (id, tracks) => {\n          // Store initial constraints.\n          for (const trackInfo of tracks) {\n            const c = constraints[trackInfo.kind];\n            if (typeof c === 'object') {\n              trackInfo.constraints = RTCUtil.deepClone(c);\n            }\n          }\n\n          const info = {\n            streamId: id,\n            streamReactTag: id,\n            tracks\n          };\n    \n          resolve(new MediaStream(info));\n      };\n\n      const failure = (type, message) => {\n          let error;\n          switch (type) {\n          case 'TypeError':\n            error = new TypeError(message);\n            break;\n          }\n          if (!error) {\n            error = new MediaStreamError({ message, name: type });\n          }\n\n          reject(error);\n      };\n\n      WebRTCModule.getUserMedia(constraints, success, failure);\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}