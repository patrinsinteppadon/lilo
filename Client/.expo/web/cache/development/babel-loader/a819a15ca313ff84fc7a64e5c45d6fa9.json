{"ast":null,"code":"'use strict';\n\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport EventTarget from 'event-target-shim';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport MediaStream from \"./MediaStream\";\nimport MediaStreamEvent from \"./MediaStreamEvent\";\nimport MediaStreamTrack from \"./MediaStreamTrack\";\nimport MediaStreamTrackEvent from \"./MediaStreamTrackEvent\";\nimport RTCDataChannel from \"./RTCDataChannel\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nimport RTCSessionDescription from \"./RTCSessionDescription\";\nimport RTCIceCandidate from \"./RTCIceCandidate\";\nimport RTCIceCandidateEvent from \"./RTCIceCandidateEvent\";\nimport RTCEvent from \"./RTCEvent\";\nimport * as RTCUtil from \"./RTCUtil\";\nimport EventEmitter from \"./EventEmitter\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar PEER_CONNECTION_EVENTS = ['connectionstatechange', 'icecandidate', 'icecandidateerror', 'iceconnectionstatechange', 'icegatheringstatechange', 'negotiationneeded', 'signalingstatechange', 'datachannel', 'addstream', 'removestream'];\nvar nextPeerConnectionId = 0;\n\nvar RTCPeerConnection = function (_EventTarget) {\n  _inherits(RTCPeerConnection, _EventTarget);\n\n  var _super = _createSuper(RTCPeerConnection);\n\n  function RTCPeerConnection(configuration) {\n    var _this;\n\n    _classCallCheck(this, RTCPeerConnection);\n\n    _this = _super.call(this);\n    _this.signalingState = 'stable';\n    _this.iceGatheringState = 'new';\n    _this.connectionState = 'new';\n    _this.iceConnectionState = 'new';\n    _this._localStreams = [];\n    _this._remoteStreams = [];\n    _this._dataChannelIds = new Set();\n    _this._peerConnectionId = nextPeerConnectionId++;\n    WebRTCModule.peerConnectionInit(configuration, _this._peerConnectionId);\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  _createClass(RTCPeerConnection, [{\n    key: \"addStream\",\n    value: function addStream(stream) {\n      var index = this._localStreams.indexOf(stream);\n\n      if (index !== -1) {\n        return;\n      }\n\n      WebRTCModule.peerConnectionAddStream(stream._reactTag, this._peerConnectionId);\n\n      this._localStreams.push(stream);\n    }\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(stream) {\n      var index = this._localStreams.indexOf(stream);\n\n      if (index === -1) {\n        return;\n      }\n\n      this._localStreams.splice(index, 1);\n\n      WebRTCModule.peerConnectionRemoveStream(stream._reactTag, this._peerConnectionId);\n    }\n  }, {\n    key: \"createOffer\",\n    value: function createOffer(options) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionCreateOffer(_this2._peerConnectionId, RTCUtil.normalizeOfferAnswerOptions(options), function (successful, data) {\n          if (successful) {\n            resolve(new RTCSessionDescription(data));\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"createAnswer\",\n    value: function createAnswer() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionCreateAnswer(_this3._peerConnectionId, RTCUtil.normalizeOfferAnswerOptions(options), function (successful, data) {\n          if (successful) {\n            resolve(new RTCSessionDescription(data));\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"setConfiguration\",\n    value: function setConfiguration(configuration) {\n      WebRTCModule.peerConnectionSetConfiguration(configuration, this._peerConnectionId);\n    }\n  }, {\n    key: \"setLocalDescription\",\n    value: function setLocalDescription(sessionDescription) {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionSetLocalDescription(sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription, _this4._peerConnectionId, function (successful, data) {\n          if (successful) {\n            _this4.localDescription = sessionDescription;\n            resolve();\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"setRemoteDescription\",\n    value: function setRemoteDescription(sessionDescription) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionSetRemoteDescription(sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription, _this5._peerConnectionId, function (successful, data) {\n          if (successful) {\n            _this5.remoteDescription = sessionDescription;\n            resolve();\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"addIceCandidate\",\n    value: function addIceCandidate(candidate) {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionAddICECandidate(candidate.toJSON ? candidate.toJSON() : candidate, _this6._peerConnectionId, function (successful) {\n          if (successful) {\n            resolve();\n          } else {\n            reject(new Error('Failed to add ICE candidate'));\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return WebRTCModule.peerConnectionGetStats(this._peerConnectionId).then(function (data) {\n        return new Map(JSON.parse(data));\n      });\n    }\n  }, {\n    key: \"getLocalStreams\",\n    value: function getLocalStreams() {\n      return this._localStreams.slice();\n    }\n  }, {\n    key: \"getRemoteStreams\",\n    value: function getRemoteStreams() {\n      return this._remoteStreams.slice();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      WebRTCModule.peerConnectionClose(this._peerConnectionId);\n    }\n  }, {\n    key: \"_getTrack\",\n    value: function _getTrack(streamReactTag, trackId) {\n      var stream = this._remoteStreams.find(function (stream) {\n        return stream._reactTag === streamReactTag;\n      });\n\n      return stream && stream._tracks.find(function (track) {\n        return track.id === trackId;\n      });\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      this._subscriptions.forEach(function (e) {\n        return e.remove();\n      });\n\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this7 = this;\n\n      this._subscriptions = [EventEmitter.addListener('peerConnectionOnRenegotiationNeeded', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        _this7.dispatchEvent(new RTCEvent('negotiationneeded'));\n      }), EventEmitter.addListener('peerConnectionIceConnectionChanged', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        _this7.iceConnectionState = ev.iceConnectionState;\n\n        _this7.dispatchEvent(new RTCEvent('iceconnectionstatechange'));\n\n        if (ev.iceConnectionState === 'closed') {\n          _this7._unregisterEvents();\n        }\n      }), EventEmitter.addListener('peerConnectionStateChanged', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        _this7.connectionState = ev.connectionState;\n\n        _this7.dispatchEvent(new RTCEvent('connectionstatechange'));\n\n        if (ev.connectionState === 'closed') {\n          _this7._unregisterEvents();\n        }\n      }), EventEmitter.addListener('peerConnectionSignalingStateChanged', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        _this7.signalingState = ev.signalingState;\n\n        _this7.dispatchEvent(new RTCEvent('signalingstatechange'));\n      }), EventEmitter.addListener('peerConnectionAddedStream', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        var stream = new MediaStream(ev);\n\n        _this7._remoteStreams.push(stream);\n\n        _this7.dispatchEvent(new MediaStreamEvent('addstream', {\n          stream: stream\n        }));\n      }), EventEmitter.addListener('peerConnectionRemovedStream', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        var stream = _this7._remoteStreams.find(function (s) {\n          return s._reactTag === ev.streamId;\n        });\n\n        if (stream) {\n          var index = _this7._remoteStreams.indexOf(stream);\n\n          if (index !== -1) {\n            _this7._remoteStreams.splice(index, 1);\n          }\n        }\n\n        _this7.dispatchEvent(new MediaStreamEvent('removestream', {\n          stream: stream\n        }));\n      }), EventEmitter.addListener('mediaStreamTrackMuteChanged', function (ev) {\n        if (ev.peerConnectionId !== _this7._peerConnectionId) {\n          return;\n        }\n\n        var track = _this7._getTrack(ev.streamReactTag, ev.trackId);\n\n        if (track) {\n          track.muted = ev.muted;\n          var eventName = ev.muted ? 'mute' : 'unmute';\n          track.dispatchEvent(new MediaStreamTrackEvent(eventName, {\n            track: track\n          }));\n        }\n      }), EventEmitter.addListener('peerConnectionGotICECandidate', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        var candidate = new RTCIceCandidate(ev.candidate);\n        var event = new RTCIceCandidateEvent('icecandidate', {\n          candidate: candidate\n        });\n\n        _this7.dispatchEvent(event);\n      }), EventEmitter.addListener('peerConnectionIceGatheringChanged', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        _this7.iceGatheringState = ev.iceGatheringState;\n\n        if (_this7.iceGatheringState === 'complete') {\n          _this7.dispatchEvent(new RTCIceCandidateEvent('icecandidate', null));\n        }\n\n        _this7.dispatchEvent(new RTCEvent('icegatheringstatechange'));\n      }), EventEmitter.addListener('peerConnectionDidOpenDataChannel', function (ev) {\n        if (ev.id !== _this7._peerConnectionId) {\n          return;\n        }\n\n        var evDataChannel = ev.dataChannel;\n        var id = evDataChannel.id;\n\n        if (typeof id !== 'number' || id === -1) {\n          return;\n        }\n\n        var channel = new RTCDataChannel(_this7._peerConnectionId, evDataChannel.label, evDataChannel);\n\n        _this7._dataChannelIds.add(id);\n\n        _this7.dispatchEvent(new RTCDataChannelEvent('datachannel', {\n          channel: channel\n        }));\n      })];\n    }\n  }, {\n    key: \"createDataChannel\",\n    value: function createDataChannel(label, dataChannelDict) {\n      var id;\n      var dataChannelIds = this._dataChannelIds;\n\n      if (dataChannelDict && 'id' in dataChannelDict) {\n        id = dataChannelDict.id;\n\n        if (typeof id !== 'number') {\n          throw new TypeError('DataChannel id must be a number: ' + id);\n        }\n\n        if (dataChannelIds.has(id)) {\n          throw new ResourceInUse('DataChannel id already in use: ' + id);\n        }\n      } else {\n        for (id = 1; id < 65535 && dataChannelIds.has(id); ++id) {\n          ;\n        }\n\n        dataChannelDict = _extends({\n          id: id\n        }, dataChannelDict);\n      }\n\n      WebRTCModule.createDataChannel(this._peerConnectionId, label, dataChannelDict);\n      dataChannelIds.add(id);\n      return new RTCDataChannel(this._peerConnectionId, label, dataChannelDict);\n    }\n  }]);\n\n  return RTCPeerConnection;\n}(EventTarget(PEER_CONNECTION_EVENTS));\n\nexport { RTCPeerConnection as default };","map":{"version":3,"sources":["/Users/paola/Documents/Capstone/lilo/node_modules/react-native-webrtc/RTCPeerConnection.js"],"names":["EventTarget","MediaStream","MediaStreamEvent","MediaStreamTrack","MediaStreamTrackEvent","RTCDataChannel","RTCDataChannelEvent","RTCSessionDescription","RTCIceCandidate","RTCIceCandidateEvent","RTCEvent","RTCUtil","EventEmitter","WebRTCModule","NativeModules","PEER_CONNECTION_EVENTS","nextPeerConnectionId","RTCPeerConnection","configuration","signalingState","iceGatheringState","connectionState","iceConnectionState","_localStreams","_remoteStreams","_dataChannelIds","Set","_peerConnectionId","peerConnectionInit","_registerEvents","stream","index","indexOf","peerConnectionAddStream","_reactTag","push","splice","peerConnectionRemoveStream","options","Promise","resolve","reject","peerConnectionCreateOffer","normalizeOfferAnswerOptions","successful","data","peerConnectionCreateAnswer","peerConnectionSetConfiguration","sessionDescription","peerConnectionSetLocalDescription","toJSON","localDescription","peerConnectionSetRemoteDescription","remoteDescription","candidate","peerConnectionAddICECandidate","Error","peerConnectionGetStats","then","Map","JSON","parse","slice","peerConnectionClose","streamReactTag","trackId","find","_tracks","track","id","_subscriptions","forEach","e","remove","addListener","ev","dispatchEvent","_unregisterEvents","s","streamId","peerConnectionId","_getTrack","muted","eventName","event","evDataChannel","dataChannel","channel","label","add","dataChannelDict","dataChannelIds","TypeError","has","ResourceInUse","createDataChannel"],"mappings":"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","sourcesContent":["'use strict';\n\nimport EventTarget from 'event-target-shim';\nimport { NativeModules, NativeEventEmitter } from 'react-native';\n\nimport MediaStream from './MediaStream';\nimport MediaStreamEvent from './MediaStreamEvent';\nimport MediaStreamTrack from './MediaStreamTrack';\nimport MediaStreamTrackEvent from './MediaStreamTrackEvent';\nimport RTCDataChannel from './RTCDataChannel';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport RTCSessionDescription from './RTCSessionDescription';\nimport RTCIceCandidate from './RTCIceCandidate';\nimport RTCIceCandidateEvent from './RTCIceCandidateEvent';\nimport RTCEvent from './RTCEvent';\nimport * as RTCUtil from './RTCUtil';\nimport EventEmitter from './EventEmitter';\n\nconst {WebRTCModule} = NativeModules;\n\ntype RTCSignalingState =\n  'stable' |\n  'have-local-offer' |\n  'have-remote-offer' |\n  'have-local-pranswer' |\n  'have-remote-pranswer' |\n  'closed';\n\ntype RTCIceGatheringState =\n  'new' |\n  'gathering' |\n  'complete';\n\ntype RTCPeerConnectionState =\n  'new' |\n  'connecting' |\n  'connected' |\n  'disconnected' |\n  'failed' |\n  'closed';\n\ntype RTCIceConnectionState =\n  'new' |\n  'checking' |\n  'connected' |\n  'completed' |\n  'failed' |\n  'disconnected' |\n  'closed';\n\nconst PEER_CONNECTION_EVENTS = [\n  'connectionstatechange',\n  'icecandidate',\n  'icecandidateerror',\n  'iceconnectionstatechange',\n  'icegatheringstatechange',\n  'negotiationneeded',\n  'signalingstatechange',\n  // Peer-to-peer Data API:\n  'datachannel',\n  // old:\n  'addstream',\n  'removestream',\n];\n\nlet nextPeerConnectionId = 0;\n\nexport default class RTCPeerConnection extends EventTarget(PEER_CONNECTION_EVENTS) {\n  localDescription: RTCSessionDescription;\n  remoteDescription: RTCSessionDescription;\n\n  signalingState: RTCSignalingState = 'stable';\n  iceGatheringState: RTCIceGatheringState = 'new';\n  connectionState: RTCPeerConnectionState = 'new';\n  iceConnectionState: RTCIceConnectionState = 'new';\n\n  onconnectionstatechange: ?Function;\n  onicecandidate: ?Function;\n  onicecandidateerror: ?Function;\n  oniceconnectionstatechange: ?Function;\n  onicegatheringstatechange: ?Function;\n  onnegotiationneeded: ?Function;\n  onsignalingstatechange: ?Function;\n\n  onaddstream: ?Function;\n  onremovestream: ?Function;\n\n  _peerConnectionId: number;\n  _localStreams: Array<MediaStream> = [];\n  _remoteStreams: Array<MediaStream> = [];\n  _subscriptions: Array<any>;\n\n  /**\n   * The RTCDataChannel.id allocator of this RTCPeerConnection.\n   */\n  _dataChannelIds: Set = new Set();\n\n  constructor(configuration) {\n    super();\n    this._peerConnectionId = nextPeerConnectionId++;\n    WebRTCModule.peerConnectionInit(configuration, this._peerConnectionId);\n    this._registerEvents();\n  }\n\n  addStream(stream: MediaStream) {\n      const index = this._localStreams.indexOf(stream);\n      if (index !== -1) {\n          return;\n      }\n      WebRTCModule.peerConnectionAddStream(stream._reactTag, this._peerConnectionId);\n      this._localStreams.push(stream);\n  }\n\n  removeStream(stream: MediaStream) {\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n          return;\n      }\n      this._localStreams.splice(index, 1);\n      WebRTCModule.peerConnectionRemoveStream(stream._reactTag, this._peerConnectionId);\n  }\n\n  createOffer(options) {\n    return new Promise((resolve, reject) => {\n      WebRTCModule.peerConnectionCreateOffer(\n        this._peerConnectionId,\n        RTCUtil.normalizeOfferAnswerOptions(options),\n        (successful, data) => {\n          if (successful) {\n            resolve(new RTCSessionDescription(data));\n          } else {\n            reject(data); // TODO: convert to NavigatorUserMediaError\n          }\n        });\n    });\n  }\n\n  createAnswer(options = {}) {\n    return new Promise((resolve, reject) => {\n      WebRTCModule.peerConnectionCreateAnswer(\n        this._peerConnectionId,\n        RTCUtil.normalizeOfferAnswerOptions(options),\n        (successful, data) => {\n          if (successful) {\n            resolve(new RTCSessionDescription(data));\n          } else {\n            reject(data);\n          }\n        });\n    });\n  }\n\n  setConfiguration(configuration) {\n    WebRTCModule.peerConnectionSetConfiguration(configuration, this._peerConnectionId);\n  }\n\n  setLocalDescription(sessionDescription: RTCSessionDescription) {\n    return new Promise((resolve, reject) => {\n      WebRTCModule.peerConnectionSetLocalDescription(\n        sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription,\n        this._peerConnectionId,\n        (successful, data) => {\n          if (successful) {\n            this.localDescription = sessionDescription;\n            resolve();\n          } else {\n            reject(data);\n          }\n      });\n    });\n  }\n\n  setRemoteDescription(sessionDescription: RTCSessionDescription) {\n    return new Promise((resolve, reject) => {\n      WebRTCModule.peerConnectionSetRemoteDescription(\n        sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription,\n        this._peerConnectionId,\n        (successful, data) => {\n          if (successful) {\n            this.remoteDescription = sessionDescription;\n            resolve();\n          } else {\n            reject(data);\n          }\n      });\n    });\n  }\n\n  addIceCandidate(candidate) {\n    return new Promise((resolve, reject) => {\n      WebRTCModule.peerConnectionAddICECandidate(\n        candidate.toJSON ? candidate.toJSON() : candidate,\n        this._peerConnectionId,\n        (successful) => {\n          if (successful) {\n            resolve()\n          } else {\n            // XXX: This should be OperationError\n            reject(new Error('Failed to add ICE candidate'));\n          }\n      });\n    });\n  }\n\n  getStats() {\n    return WebRTCModule.peerConnectionGetStats(this._peerConnectionId)\n        .then( data =>  {\n           /* On both Android and iOS it is faster to construct a single\n            JSON string representing the Map of StatsReports and have it\n            pass through the React Native bridge rather than the Map of\n            StatsReports. While the implementations do try to be faster in\n            general, the stress is on being faster to pass through the React\n            Native bridge which is a bottleneck that tends to be visible in\n            the UI when there is congestion involving UI-related passing.\n\n            TODO Implement the logic for filtering the stats based on \n            the sender/receiver\n            */\n            return new Map(JSON.parse(data));\n        });\n  }\n\n  getLocalStreams() {\n    return this._localStreams.slice();\n  }\n\n  getRemoteStreams() {\n    return this._remoteStreams.slice();\n  }\n\n  close() {\n    WebRTCModule.peerConnectionClose(this._peerConnectionId);\n  }\n\n  _getTrack(streamReactTag, trackId): MediaStreamTrack {\n    const stream\n      = this._remoteStreams.find(\n          stream => stream._reactTag === streamReactTag);\n\n    return stream && stream._tracks.find(track => track.id === trackId);\n  }\n\n  _unregisterEvents(): void {\n    this._subscriptions.forEach(e => e.remove());\n    this._subscriptions = [];\n  }\n\n  _registerEvents(): void {\n    this._subscriptions = [\n      EventEmitter.addListener('peerConnectionOnRenegotiationNeeded', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        this.dispatchEvent(new RTCEvent('negotiationneeded'));\n      }),\n      EventEmitter.addListener('peerConnectionIceConnectionChanged', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        this.iceConnectionState = ev.iceConnectionState;\n        this.dispatchEvent(new RTCEvent('iceconnectionstatechange'));\n        if (ev.iceConnectionState === 'closed') {\n          // This PeerConnection is done, clean up event handlers.\n          this._unregisterEvents();\n        }\n      }),\n      EventEmitter.addListener('peerConnectionStateChanged', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        this.connectionState = ev.connectionState;\n        this.dispatchEvent(new RTCEvent('connectionstatechange'));\n        if (ev.connectionState === 'closed') {\n          // This PeerConnection is done, clean up event handlers.\n          this._unregisterEvents();\n        }\n      }),\n      EventEmitter.addListener('peerConnectionSignalingStateChanged', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        this.signalingState = ev.signalingState;\n        this.dispatchEvent(new RTCEvent('signalingstatechange'));\n      }),\n      EventEmitter.addListener('peerConnectionAddedStream', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        const stream = new MediaStream(ev);\n        this._remoteStreams.push(stream);\n        this.dispatchEvent(new MediaStreamEvent('addstream', {stream}));\n      }),\n      EventEmitter.addListener('peerConnectionRemovedStream', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        const stream = this._remoteStreams.find(s => s._reactTag === ev.streamId);\n        if (stream) {\n          const index = this._remoteStreams.indexOf(stream);\n          if (index !== -1) {\n            this._remoteStreams.splice(index, 1);\n          }\n        }\n        this.dispatchEvent(new MediaStreamEvent('removestream', {stream}));\n      }),\n      EventEmitter.addListener('mediaStreamTrackMuteChanged', ev => {\n        if (ev.peerConnectionId !== this._peerConnectionId) {\n          return;\n        }\n        const track = this._getTrack(ev.streamReactTag, ev.trackId);\n        if (track) {\n          track.muted = ev.muted;\n          const eventName = ev.muted ? 'mute' : 'unmute';\n          track.dispatchEvent(new MediaStreamTrackEvent(eventName, {track}));\n        }\n      }),\n      EventEmitter.addListener('peerConnectionGotICECandidate', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        const candidate = new RTCIceCandidate(ev.candidate);\n        const event = new RTCIceCandidateEvent('icecandidate', {candidate});\n        this.dispatchEvent(event);\n      }),\n      EventEmitter.addListener('peerConnectionIceGatheringChanged', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        this.iceGatheringState = ev.iceGatheringState;\n\n        if (this.iceGatheringState === 'complete') {\n          this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', null));\n        }\n\n        this.dispatchEvent(new RTCEvent('icegatheringstatechange'));\n      }),\n      EventEmitter.addListener('peerConnectionDidOpenDataChannel', ev => {\n        if (ev.id !== this._peerConnectionId) {\n          return;\n        }\n        const evDataChannel = ev.dataChannel;\n        const id = evDataChannel.id;\n        // XXX RTP data channels are not defined by the WebRTC standard, have\n        // been deprecated in Chromium, and Google have decided (in 2015) to no\n        // longer support them (in the face of multiple reported issues of\n        // breakages).\n        if (typeof id !== 'number' || id === -1) {\n          return;\n        }\n        const channel\n          = new RTCDataChannel(\n              this._peerConnectionId,\n              evDataChannel.label,\n              evDataChannel);\n        // XXX webrtc::PeerConnection checked that id was not in use in its own\n        // SID allocator before it invoked us. Additionally, its own SID\n        // allocator is the authority on ResourceInUse. Consequently, it is\n        // (pretty) safe to update our RTCDataChannel.id allocator without\n        // checking for ResourceInUse.\n        this._dataChannelIds.add(id);\n        this.dispatchEvent(new RTCDataChannelEvent('datachannel', {channel}));\n      })\n    ];\n  }\n\n  /**\n   * Creates a new RTCDataChannel object with the given label. The\n   * RTCDataChannelInit dictionary can be used to configure properties of the\n   * underlying channel such as data reliability.\n   *\n   * @param {string} label - the value with which the label attribute of the new\n   * instance is to be initialized\n   * @param {RTCDataChannelInit} dataChannelDict - an optional dictionary of\n   * values with which to initialize corresponding attributes of the new\n   * instance such as id\n   */\n  createDataChannel(label: string, dataChannelDict?: ?RTCDataChannelInit) {\n    let id;\n    const dataChannelIds = this._dataChannelIds;\n    if (dataChannelDict && 'id' in dataChannelDict) {\n      id = dataChannelDict.id;\n      if (typeof id !== 'number') {\n        throw new TypeError('DataChannel id must be a number: ' + id);\n      }\n      if (dataChannelIds.has(id)) {\n        throw new ResourceInUse('DataChannel id already in use: ' + id);\n      }\n    } else {\n      // Allocate a new id.\n      // TODO Remembering the last used/allocated id and then incrementing it to\n      // generate the next id to use will surely be faster. However, I want to\n      // reuse ids (in the future) as the RTCDataChannel.id space is limited to\n      // unsigned short by the standard:\n      // https://www.w3.org/TR/webrtc/#dom-datachannel-id. Additionally, 65535\n      // is reserved due to SCTP INIT and INIT-ACK chunks only allowing a\n      // maximum of 65535 streams to be negotiated (as defined by the WebRTC\n      // Data Channel Establishment Protocol).\n      for (id = 1; id < 65535 && dataChannelIds.has(id); ++id);\n      // TODO Throw an error if no unused id is available.\n      dataChannelDict = Object.assign({id}, dataChannelDict);\n    }\n    WebRTCModule.createDataChannel(\n        this._peerConnectionId,\n        label,\n        dataChannelDict);\n    dataChannelIds.add(id);\n    return new RTCDataChannel(this._peerConnectionId, label, dataChannelDict);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}