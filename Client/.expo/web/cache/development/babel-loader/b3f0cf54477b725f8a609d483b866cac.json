{"ast":null,"code":"'use strict';\n\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport base64 from 'base64-js';\nimport EventTarget from 'event-target-shim';\nimport MessageEvent from \"./MessageEvent\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nimport EventEmitter from \"./EventEmitter\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar DATA_CHANNEL_EVENTS = ['open', 'message', 'bufferedamountlow', 'close', 'error'];\n\nvar ResourceInUse = function (_Error) {\n  _inherits(ResourceInUse, _Error);\n\n  var _super = _createSuper(ResourceInUse);\n\n  function ResourceInUse() {\n    _classCallCheck(this, ResourceInUse);\n\n    return _super.apply(this, arguments);\n  }\n\n  return ResourceInUse;\n}(_wrapNativeSuper(Error));\n\nvar RTCDataChannel = function (_EventTarget) {\n  _inherits(RTCDataChannel, _EventTarget);\n\n  var _super2 = _createSuper(RTCDataChannel);\n\n  function RTCDataChannel(peerConnectionId, label, dataChannelDict) {\n    var _this;\n\n    _classCallCheck(this, RTCDataChannel);\n\n    _this = _super2.call(this);\n    _this.binaryType = 'arraybuffer';\n    _this.bufferedAmount = 0;\n    _this.bufferedAmountLowThreshold = 0;\n    _this.maxPacketLifeTime = null;\n    _this.maxRetransmits = null;\n    _this.negotiated = false;\n    _this.ordered = true;\n    _this.protocol = '';\n    _this.readyState = 'connecting';\n    _this._peerConnectionId = peerConnectionId;\n    _this.label = label;\n    _this.id = 'id' in dataChannelDict ? dataChannelDict.id : -1;\n    _this.ordered = !!dataChannelDict.ordered;\n    _this.maxPacketLifeTime = dataChannelDict.maxPacketLifeTime;\n    _this.maxRetransmits = dataChannelDict.maxRetransmits;\n    _this.protocol = dataChannelDict.protocol || '';\n    _this.negotiated = !!dataChannelDict.negotiated;\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  _createClass(RTCDataChannel, [{\n    key: \"send\",\n    value: function send(data) {\n      if (typeof data === 'string') {\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, data, 'text');\n        return;\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n      } else if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      } else {\n        throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n      }\n\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, base64.fromByteArray(data), 'binary');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.readyState === 'closing' || this.readyState === 'closed') {\n        return;\n      }\n\n      this.readyState = 'closing';\n      WebRTCModule.dataChannelClose(this._peerConnectionId, this.id);\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      this._subscriptions.forEach(function (e) {\n        return e.remove();\n      });\n\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this2 = this;\n\n      this._subscriptions = [EventEmitter.addListener('dataChannelStateChanged', function (ev) {\n        if (ev.peerConnectionId !== _this2._peerConnectionId || ev.id !== _this2.id) {\n          return;\n        }\n\n        _this2.readyState = ev.state;\n\n        if (_this2.readyState === 'open') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('open', {\n            channel: _this2\n          }));\n        } else if (_this2.readyState === 'close') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('close', {\n            channel: _this2\n          }));\n\n          _this2._unregisterEvents();\n        }\n      }), EventEmitter.addListener('dataChannelReceiveMessage', function (ev) {\n        if (ev.peerConnectionId !== _this2._peerConnectionId || ev.id !== _this2.id) {\n          return;\n        }\n\n        var data = ev.data;\n\n        if (ev.type === 'binary') {\n          data = base64.toByteArray(ev.data).buffer;\n        }\n\n        _this2.dispatchEvent(new MessageEvent('message', {\n          data: data\n        }));\n      })];\n    }\n  }]);\n\n  return RTCDataChannel;\n}(EventTarget(DATA_CHANNEL_EVENTS));\n\nexport { RTCDataChannel as default };","map":{"version":3,"sources":["/Users/paola/Documents/Capstone/lilo/node_modules/react-native-webrtc/RTCDataChannel.js"],"names":["base64","EventTarget","MessageEvent","RTCDataChannelEvent","EventEmitter","WebRTCModule","NativeModules","DATA_CHANNEL_EVENTS","ResourceInUse","Error","RTCDataChannel","peerConnectionId","label","dataChannelDict","binaryType","bufferedAmount","bufferedAmountLowThreshold","maxPacketLifeTime","maxRetransmits","negotiated","ordered","protocol","readyState","_peerConnectionId","id","_registerEvents","data","dataChannelSend","ArrayBuffer","isView","Uint8Array","buffer","byteOffset","byteLength","TypeError","fromByteArray","dataChannelClose","_subscriptions","forEach","e","remove","addListener","ev","state","dispatchEvent","channel","_unregisterEvents","type","toByteArray"],"mappings":"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","sourcesContent":["'use strict';\n\nimport { NativeModules } from 'react-native';\nimport base64 from 'base64-js';\nimport EventTarget from 'event-target-shim';\nimport MessageEvent from './MessageEvent';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport EventEmitter from './EventEmitter';\n\nconst {WebRTCModule} = NativeModules;\n\ntype RTCDataChannelInit = {\n  ordered?: boolean;\n  maxPacketLifeTime?: number;\n  maxRetransmits?: number;\n  protocol?: string;\n  negotiated?: boolean;\n  id?: number;\n  // deprecated:\n  maxRetransmitTime?: number,\n};\n\ntype RTCDataChannelState =\n  'connecting' |\n  'open' |\n  'closing' |\n  'closed';\n\nconst DATA_CHANNEL_EVENTS = [\n  'open',\n  'message',\n  'bufferedamountlow',\n  'close',\n  'error',\n];\n\nclass ResourceInUse extends Error {}\n\nexport default class RTCDataChannel extends EventTarget(DATA_CHANNEL_EVENTS) {\n\n  _peerConnectionId: number;\n\n  binaryType: 'arraybuffer' = 'arraybuffer'; // we only support 'arraybuffer'\n  bufferedAmount: number = 0;\n  bufferedAmountLowThreshold: number = 0;\n  id: number;\n  label: string;\n  maxPacketLifeTime: ?number = null;\n  maxRetransmits: ?number = null;\n  negotiated: boolean = false;\n  ordered: boolean = true;\n  protocol: string = '';\n  readyState: RTCDataChannelState = 'connecting';\n\n  onopen: ?Function;\n  onmessage: ?Function;\n  onbufferedamountlow: ?Function;\n  onerror: ?Function;\n  onclose: ?Function;\n\n  constructor(\n      peerConnectionId: number,\n      label: string,\n      dataChannelDict: RTCDataChannelInit) {\n    super();\n\n    this._peerConnectionId = peerConnectionId;\n\n    this.label = label;\n\n    // The standard defines dataChannelDict as optional for\n    // RTCPeerConnection#createDataChannel and that is how we have implemented\n    // the method in question. However, the method will (1) allocate an\n    // RTCDataChannel.id if the caller has not specified a value and (2)\n    // pass it to RTCDataChannel's constructor via dataChannelDict.\n    // Consequently, dataChannelDict is not optional for RTCDataChannel's\n    // constructor.\n    this.id = ('id' in dataChannelDict) ? dataChannelDict.id : -1;\n    this.ordered = !!dataChannelDict.ordered;\n    this.maxPacketLifeTime = dataChannelDict.maxPacketLifeTime;\n    this.maxRetransmits = dataChannelDict.maxRetransmits;\n    this.protocol = dataChannelDict.protocol || '';\n    this.negotiated = !!dataChannelDict.negotiated;\n\n    this._registerEvents();\n  }\n\n  send(data: string | ArrayBuffer | ArrayBufferView) {\n    if (typeof data === 'string') {\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, data, 'text');\n      return;\n    }\n\n    // Safely convert the buffer object to an Uint8Array for base64-encoding\n    if (ArrayBuffer.isView(data)) {\n      data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    } else if (data instanceof ArrayBuffer) {\n      data = new Uint8Array(data);\n    } else {\n      throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n    }\n    WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, base64.fromByteArray(data), 'binary');\n  }\n\n  close() {\n    if (this.readyState === 'closing' || this.readyState === 'closed') {\n      return;\n    }\n    this.readyState = 'closing';\n    WebRTCModule.dataChannelClose(this._peerConnectionId, this.id);\n  }\n\n  _unregisterEvents() {\n    this._subscriptions.forEach(e => e.remove());\n    this._subscriptions = [];\n  }\n\n  _registerEvents() {\n    this._subscriptions = [\n      EventEmitter.addListener('dataChannelStateChanged', ev => {\n        if (ev.peerConnectionId !== this._peerConnectionId\n            || ev.id !== this.id) {\n          return;\n        }\n        this.readyState = ev.state;\n        if (this.readyState === 'open') {\n          this.dispatchEvent(new RTCDataChannelEvent('open', {channel: this}));\n        } else if (this.readyState === 'close') {\n          this.dispatchEvent(new RTCDataChannelEvent('close', {channel: this}));\n          this._unregisterEvents();\n        }\n      }),\n      EventEmitter.addListener('dataChannelReceiveMessage', ev => {\n        if (ev.peerConnectionId !== this._peerConnectionId\n            || ev.id !== this.id) {\n          return;\n        }\n        let data = ev.data;\n        if (ev.type === 'binary') {\n          data = base64.toByteArray(ev.data).buffer;\n        }\n        this.dispatchEvent(new MessageEvent('message', {data}));\n      }),\n    ];\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}